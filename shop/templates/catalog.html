{% block content %}
{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Catalog</title>
    <link rel="stylesheet"  href="{% static 'css/catalog.css' %}">
    <!-- Add this script tag to your HTML to include Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.10/firebase-analytics.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
<body>
{% include 'base.html' %}

<div class="everything" style="margin-top: 120px">
    <div class="filters-section">
        <div class="categories" style="display: none;">
            <div class="categories-label">Categories</div><br>
            <ul class="categories-list">

            </ul>
        </div>
        <div class="filters">
            <div class="filters-label">Filters<hr></div><br>
            <div class="filter-name">
                <label for="contains-in-name">Name</label>
                <hr>
                <input type="text" id="contains-in-name" placeholder="Contains in name..."><br>
            </div><br>
            <div class="filter-price">
                <label for="slider-price">Price</label>
                <hr>
               <div class="range_container">
                    <div class="sliders_control">
                       <input id="fromSlider" type="range" value="0" min="0" max="800" step="5"/>
                       <input id="toSlider" type="range" value="800" min="0" max="800" step="5"/>
                    </div>
                    <div class="form_control">
                      <div class="form_control_container">
                          <span class="fromInput-text">{{ currency }}0</span>
                      </div>
                          <div class="form_control_container">
                             <span class="toInput-text">{{ currency }}800</span>
                          </div>
                    </div>
                </div>
            </div>
            <div class="filter-crystal-color">
                Crystal color
                <hr>

                <div class="crystals">
                    <div id="crystal1">
                        <input class="crystal-checkbox" type="checkbox" id="checkbox1" name="checkbox1" value="Pink">
                        <label class="checkbox-label" for="checkbox1">Pink</label>
                    </div>
                    <div id="crystal2">
                        <input class="crystal-checkbox" type="checkbox" id="checkbox2" name="checkbox2" value="Red">
                        <label class="checkbox-label" for="checkbox2">Red</label>
                    </div>
                    <div id="crystal3">
                        <input class="crystal-checkbox" type="checkbox" id="checkbox3" name="checkbox3" value="Blue">
                        <label class="checkbox-label" for="checkbox3">Blue</label>
                    </div>
                </div>
                <div class="remove-filters-container" id="crystals">  <span class="remove-filters"><i class="fa-solid fa-close"></i> Reset this group</span></div>

            </div>
            <br>
            <div class="filter-plating">
                Plating material
                <hr>

                <div class="platings">
                    <div id="plating1">
                        <input class="plating-checkbox" type="checkbox" id="checkboxPL1" name="checkboxPL1" value="Rhodium">
                        <label class="checkbox-label" for="checkboxPL1">Rhodium</label>
                    </div>
                    <div id="plating2">
                        <input class="plating-checkbox" type="checkbox" id="checkboxPL2" name="checkboxPL2" value="Gold">
                        <label class="checkbox-label" for="checkboxPL2">Gold</label>
                    </div>
                    <div id="plating3">
                        <input class="plating-checkbox" type="checkbox" id="checkboxPL3" name="checkboxPL3" value="Rose Gold">
                        <label class="checkbox-label" for="checkboxPL3">Rose Gold</label>
                    </div>
                    <div id="plating4">
                        <input class="plating-checkbox" type="checkbox" id="checkboxPL4" name="checkboxPL4" value="Without">
                        <label class="checkbox-label" for="checkboxPL4">Without</label>
                    </div>
                </div>
               <div class="remove-filters-container" id="platings">  <span class="remove-filters"><i class="fa-solid fa-close"></i> Reset this group</span></div>
            </div><br>
            <div class="filter-base">
                Base material
                <hr>
                <div class="bases">
                    <div id="base1">
                        <input class="base-checkbox" type="checkbox" id="checkboxB1" name="checkboxB1" value="Steel">
                        <label class="checkbox-label" for="checkboxB1">Steel</label>
                    </div>
                    <div id="base2">
                        <input class="base-checkbox" type="checkbox" id="checkboxB2" name="checkboxB2" value="Steel Brass">
                        <label class="checkbox-label" for="checkboxB2">Steel Brass</label>
                    </div>
                </div>

                <div class="remove-filters-container" id="bases">  <span class="remove-filters"><i class="fa-solid fa-close"></i> Reset this group</span></div>
            </div><br>
            <div class="filter-size">
                Size
                <hr>
                <div class="sizes">
                    <div id="size1">
                        <input class="size-checkbox" type="checkbox" id="checkboxS1" name="checkboxS1" value="S">
                        <label class="checkbox-label" for="checkboxS1">S</label>
                    </div>
                    <div id="size2">
                        <input class="size-checkbox" type="checkbox" id="checkboxS2" name="checkboxS2" value="M">
                        <label class="checkbox-label" for="checkboxS2">M</label>
                    </div>
                    <div id="size3">
                        <input class="size-checkbox" type="checkbox" id="checkboxS3" name="checkboxS3" value="L">
                        <label class="checkbox-label" for="checkboxS3">L</label>
                    </div>
                    <div id="size4">
                        <input class="size-checkbox" type="checkbox" id="checkboxS4" name="checkboxS4" value="XL">
                        <label class="checkbox-label" for="checkboxS4">XL</label>
                    </div>
                </div>

                <div class="remove-filters-container" id="sizes">  <span class="remove-filters"><i class="fa-solid fa-close"></i> Reset this group</span></div>
            </div>

{#            <button id="submit-button">Submit filters</button>#}
        </div>
    </div>
    <div class="products-section">
        <div class="view-settings">
            <div class="select-per-page">

                <span>Items per page: </span>
                <select id="select-items-per-page">
                    <option>20</option>
                    <option>50</option>
                    <option>100</option>
                </select>
            </div>
            <div class="select-order">

                <span>Order by: </span>
                <select id="select-order">
                    <option>Name, asc</option>
                    <option>Name, desc</option>
                    <option>Price, asc</option>
                    <option>Price, desc</option>
                </select>
            </div>
        </div>
        <div>

        </div>
        <div class="products-grid">

        </div>

        <dialog id="product-card">

        </dialog>
        <dialog id="product-card-success" >

        </dialog>
        <br>
        <hr style="width: 94%; float:left">
        <div class="pages-container">
            <div class="semi">
                <div class="pages" id="pages">
{#                    <a id="jump-to-first" href="">Jump to first</a>#}
                    <a id="previous-button" href=""><i class="fa-solid fa-chevron-left"></i> Previous</a>
{##}
                    <span id="current-page"> </span>
{##}
                    <a id="next-button" href="">Next <i class="fa-solid fa-chevron-right"></i></a>
{##}
{#                    <a id="jump-to-last" href="">Jump to last</a>#}
                </div>
            </div>
            <div id="jump" >
                <input id="page-number-input" type="number">
                <button id="button-jump-to">Jump</button>
            </div>
      </div>
</div>
</div>
{% include "widgets/overlay.html" %}
</body>
<script  type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js';

    import { getFirestore, collection, query, where, getDocs } from 'https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js';

    var firebaseConfig = {
        apiKey: "AIzaSyAM0wDc_WO0wP3-_TPRPLENZDIHbezH7U4",
        authDomain: "flutterapp-fd5c3.firebaseapp.com",
        projectId: "flutterapp-fd5c3",
        storageBucket: "flutterapp-fd5c3.appspot.com",
        messagingSenderId: "486422895050",
        appId: "1:486422895050:web:b67eaef185d40579879733",
        measurementId: "G-JT2QVDEHLT"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    document.addEventListener("DOMContentLoaded", async function () {
        showOverlay();

        itemsPerPage = Number(document.getElementById('select-items-per-page').value);

        let unfilteredItems = await fetchAllItems(); // Fetch all items on load

        favouriteItems = await fetchFavouriteItems("{{ user.email }}");

        allItems = productsTransmutation(unfilteredItems);

        total_pages = Math.ceil(allItems.length / itemsPerPage);

        updatePage();

        buildUpPages();
        changePage(currentPage);

        constructCategories();
        constructFilters();
        setupCheckboxEventListeners('.crystal-checkbox', stoneFilters);
        setupCheckboxEventListeners('.plating-checkbox', platingFilters);
        setupCheckboxEventListeners('.base-checkbox', baseFilters);
        setupCheckboxEventListeners('.size-checkbox', sizeFilters);
        applyFilters();
        updateURL();

        hideOverlay();
    });
let sale = {{ sale|safe }};
const price_category = "{{ category|safe }}";
let itemsPerPage = 20;
let order_name = "Name";
let order_type = "asc";
let number_of_documents;
let currentPage = 1;
let total_pages = 1;
let allItems = [];
let favouriteItems = [];
let filteredItems = [];
let filters = [];
let platingFilters =  "{{ plating_catalog }}" ? ["{{ plating_catalog|safe }}"] : [];
let baseFilters = "{{ base_catalog }}" ? ["{{ base_catalog|safe }}"] : [];
let stoneFilters = [];
let sizeFilters = [];
let category = "{{ category_catalog|safe}}" || "All";
let categories = [""];
let all_crystals = [];
let all_platings = [];
let all_bases = [];

function buildUpPages() {
    const pagesContainer = document.getElementById('current-page');
    let pagesToShow = document.createDocumentFragment(); // Use a document fragment to hold elements before inserting them into the DOM

    function addPageLink(page, isCurrentPage) {
        const pageElement = document.createElement('a');
        if (isCurrentPage) {
            const boldText = document.createElement('b');
            boldText.textContent = page;
            if(currentPage === 1){
                boldText.style.padding = '10px';
            }
            pagesToShow.appendChild(boldText);
        } else {
            pageElement.href = "";
            pageElement.textContent = page;
            pageElement.addEventListener('click', function(event) {
                event.preventDefault();
                changePage(page);
            });
            pagesToShow.appendChild(pageElement);
        }
        pagesToShow.appendChild(document.createTextNode(' ')); // Add space between links
    }

    function addEllipsis() {
        pagesToShow.appendChild(document.createTextNode('... '));
    }

    if (total_pages <= 5) {
        for (let i = 1; i <= total_pages; i++) {
            addPageLink(i, i === currentPage);
        }
    } else {
        addPageLink(1, currentPage === 1);

        if (currentPage > 3) {
            addEllipsis();
        }

        let startPage = Math.max(2, currentPage - 1);
        let endPage = Math.min(currentPage + 1, total_pages - 1);

        if (currentPage === 1) {
            endPage = Math.min(3, total_pages - 1);
        } else if (currentPage === total_pages) {
            startPage = Math.max(total_pages - 2, 2);
        }

        for (let i = startPage; i <= endPage; i++) {
            addPageLink(i, i === currentPage);
        }

        if (currentPage < total_pages - 2) {
            addEllipsis();
        }

        addPageLink(total_pages, currentPage === total_pages);
    }

    // Clear the current content and append the new set of page links
    pagesContainer.innerHTML = '';
    pagesContainer.appendChild(pagesToShow);
}
function changePage(page) {
    if(page === 1){
        document.getElementById("previous-button").style.display = 'none';
    }
    else{
                document.getElementById("previous-button").style.display = 'block';
    }
    if(page === total_pages){
        document.getElementById("next-button").style.display = 'none';
    }
    else{
        document.getElementById("next-button").style.display = 'block';
    }
    currentPage = page;
    updatePage(); // Assuming you have this function implemented to refresh the content based on the current page

    buildUpPages();
}


function constructCategories(){
     const categories_div = document.querySelector('.categories');

     categories = (allItems.reduce((accumulator, document) => {
          if (!accumulator.includes(document.category)) {
            accumulator.push(document.category);
          }
          return accumulator;
        }, []));
     let ne = ["All"];

     ne = ne.concat(categories);
     const categoriesList = document.querySelector('.categories-list');
     categoriesList.innerHTML = ''; // Clear existing list items if any

     ne.forEach(categoryVar => {
        const li = document.createElement('li');
        const span = document.createElement('span');

        span.textContent = categoryVar;
        if(categoryVar === category){
            span.style.fontWeight = "600";
        }
        li.appendChild(span);
        span.addEventListener('click', function() {
            // Assuming 'category' is the global variable you mentioned
            document.querySelectorAll('.categories-list li span').forEach(li => {
                li.style.fontWeight = ""; // Use "normal" if you want to explicitly set it back to default
            });

            category = this.textContent; // Update the global variable
            this.style.fontWeight = "600";
            const newUrl = `?category=${encodeURIComponent(category)}`;
            history.pushState({path: newUrl}, '', newUrl);

            applyFilters(); // Call the applyFilters function
            updateURL();
        });
        categoriesList.appendChild(li);
    });
      categories_div.style.display = 'block';


}
function constructFilters(){
    constructCrystals();
    constructPlatings();
    constructBases();
}

function createFilterElements(containerClass, itemsArray, prefix) {
    const container = document.querySelector(`.${containerClass}`);
    container.innerHTML = ''; // Clear existing content

    itemsArray.forEach((item, index) => {
        const itemId = `${prefix}${index + 1}`;
        const checkboxId = `checkbox${prefix.toUpperCase()}${index + 1}`;

        // Create div for each item
        const itemDiv = document.createElement('div');
        itemDiv.id = itemId;

        // Create checkbox input for each item
        const checkbox = document.createElement('input');
        checkbox.className = `${prefix}-checkbox`;
        checkbox.type = 'checkbox';
        checkbox.id = checkboxId;
        checkbox.name = checkboxId;
        checkbox.value = item;

        // Create label for each checkbox
        const label = document.createElement('label');
        label.className = 'checkbox-label';
        label.htmlFor = checkboxId;
        label.textContent = item;

        // Append checkbox and label to itemDiv
        itemDiv.appendChild(checkbox);
        itemDiv.appendChild(label);

        // Append itemDiv to container
        container.appendChild(itemDiv);
    });
}

function constructCrystals() {
    let uniqueStones = new Set();
    allItems.forEach(document => {
        Object.values(document.platings).forEach(plating => {
            Object.keys(plating.stones).forEach(stoneCategory => {
                uniqueStones.add(stoneCategory);
            });
        });
    });
    createFilterElements('crystals', Array.from(uniqueStones), 'crystal');
}

function constructPlatings() {
    let uniquePlatings = new Set();
    allItems.forEach(document => {
        Object.keys(document.platings).forEach(plating => {
            uniquePlatings.add(plating);
        });
    });
    createFilterElements('platings', Array.from(uniquePlatings), 'plating');
}

function constructBases() {
    let all_bases = allItems.reduce((accumulator, document) => {
        if (!accumulator.includes(document.material)) {
            accumulator.push(document.material);
        }
        return accumulator;
    }, []);
    createFilterElements('bases', all_bases, 'base');
}


// Function to simulate changing the page (you might have your actual logic to fetch/update content here)


function setupCheckboxEventListeners(checkboxClassName, filtersArray) {
    document.querySelectorAll(checkboxClassName).forEach(checkbox => {
        checkbox.addEventListener('change', function() {
            const checkboxes = document.querySelectorAll(checkboxClassName);
            const remove_button = this.parentElement.parentElement.parentElement.querySelector('.remove-filters-container');
            const label = this.parentElement.querySelector('label');
            let textValue = this.value;

            if (this.checked) {
                toggleOffUnnecessaryCheckboxes(checkboxes, textValue);
                filtersArray.length = 0; // Clear the filters array
                remove_button.style.display = "block";
                label.style.fontWeight = "600";
                filtersArray.push(textValue);
            } else {
                filtersArray.splice(filtersArray.indexOf(textValue), 1);
                if (filtersArray.length === 0) {
                    remove_button.style.display = "none"; // Hide remove button if filters array is empty
                }
                label.style.fontWeight = "";
            }

            applyFilters();
            updateURL();
        });
    });
    document.querySelectorAll(checkboxClassName).forEach(checkbox => {
        if (filtersArray.includes(checkbox.value)) {
            // Programmatically check the checkbox without triggering the event
            checkbox.checked = true;

            // Now manually trigger the change event
            let event = new Event('change', {
                'bubbles': true,
                'cancelable': true
            });
            checkbox.dispatchEvent(event);
        }
    });
}
function updateURL() {
    const baseUrl = window.location.protocol + "//" + window.location.host + window.location.pathname;
    const queryParams = new URLSearchParams();

    // Add 'category' to the URL if it exists
    if (category) {
        queryParams.set('category', category);
    }

    // Assuming stoneFilters, platingFilters, baseFilters, and sizeFilters are global
    if (baseFilters.length > 0) {
        queryParams.set('base', baseFilters.join(',')); // If expecting multiple, join them
    }
    if (platingFilters.length > 0) {
        queryParams.set('plating', platingFilters.join(','));
    }
    if (stoneFilters.length > 0) {
        queryParams.set('crystal', stoneFilters.join(','));
    }
    if (sizeFilters.length > 0) {
        queryParams.set('size', sizeFilters.join(','));
    }

    // Use history.pushState to update the URL
    history.pushState({}, '', `${baseUrl}?${queryParams.toString()}`);
}
function toggleOffUnnecessaryCheckboxes(checkboxes, currentValue ){
     checkboxes.forEach(checkbox => {
            if (checkbox.value !== currentValue) {
                checkbox.checked = false;
                checkbox.parentElement.querySelector('label').style.fontWeight = "";
            }
     });
}
document.querySelectorAll('.remove-filters-container').forEach(container=> {
    container.addEventListener('click', function (){
       if(container.id === "platings"){
            platingFilters.length = 0;
            const platingCheckboxes = document.querySelectorAll('.plating-checkbox');
            platingCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
                checkbox.parentElement.querySelector('label').style.fontWeight = "";
            });
            removeQueryParam('plating');
       }
       else if(container.id === "sizes"){
            sizeFilters.length = 0;
            const sizesCheckboxes = document.querySelectorAll('.size-checkbox');
            sizesCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
                checkbox.parentElement.querySelector('label').style.fontWeight = "";
            });
            removeQueryParam('size');
       }
       else if(container.id === "bases"){
            baseFilters.length = 0;
            const baseCheckboxes = document.querySelectorAll('.base-checkbox');
            baseCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
                checkbox.parentElement.querySelector('label').style.fontWeight = "";
            });
            removeQueryParam('base');
       }
       else if(container.id === "crystals"){
            stoneFilters.length = 0;
            const crystal_checkboxes = document.querySelectorAll('.crystal-checkbox');
            crystal_checkboxes.forEach(checkbox => {
                checkbox.checked = false;
                checkbox.parentElement.querySelector('label').style.fontWeight = "";
            });
             removeQueryParam('crystal');
       }
       this.style.display = "none";
       applyFilters();

    });
});


function removeQueryParam(param) {
    const baseUrl = window.location.protocol + "//" + window.location.host + window.location.pathname;
    const queryParams = new URLSearchParams(window.location.search);

    // Remove the specific query parameter
    queryParams.delete(param);

    // Update the URL without reloading the page
    history.pushState({}, '', `${baseUrl}?${queryParams.toString()}`);
}


document.getElementById('contains-in-name').addEventListener('input', applyFilters);
function controlFromSlider(fromSlider, toSlider, fromInput) {
  const [from, to] = getParsed(fromSlider, toSlider);
  fillSlider(fromSlider, toSlider, '#C6C6C6', '#003665', toSlider);
  if (from > to) {
    fromSlider.value = to;
    fromInput.textContent = currency +to;
  } else {
    fromInput.textContent = currency +from;
  }
}

function controlToSlider(fromSlider, toSlider, toInput) {
  const [from, to] = getParsed(fromSlider, toSlider);
  fillSlider(fromSlider, toSlider, '#C6C6C6', '#003665', toSlider);
  setToggleAccessible(toSlider);
  if (from <= to) {
    toSlider.value = to;
    toInput.textContent = currency + to;
  } else {
    toInput.textContent = currency + from;
    toSlider.value = from;
  }
}

function getParsed(currentFrom, currentTo) {
  const from = parseInt(currentFrom.value, 10);
  const to = parseInt(currentTo.value, 10);
  return [from, to];
}

function fillSlider(from, to, sliderColor, rangeColor, controlSlider) {
    const rangeDistance = to.max-to.min;
    const fromPosition = from.value - to.min;
    const toPosition = to.value - to.min;
    controlSlider.style.background = `linear-gradient(
      to right,
      ${sliderColor} 0%,
      ${sliderColor} ${(fromPosition)/(rangeDistance)*100}%,
      ${rangeColor} ${((fromPosition)/(rangeDistance))*100}%,
      ${rangeColor} ${(toPosition)/(rangeDistance)*100}%,
      ${sliderColor} ${(toPosition)/(rangeDistance)*100}%,
      ${sliderColor} 100%)`;
}

function setToggleAccessible(currentTarget) {
  const toSlider = document.querySelector('#toSlider');
  if (Number(currentTarget.value) <= 0 ) {
    toSlider.style.zIndex = 2;
  } else {
    toSlider.style.zIndex = 0;
  }
}

const fromSlider = document.querySelector('#fromSlider');
const toSlider = document.querySelector('#toSlider');
const fromInputText = document.querySelector('.fromInput-text');
const toInputText = document.querySelector('.toInput-text');
fillSlider(fromSlider, toSlider, '#C6C6C6', '#003665', toSlider);
setToggleAccessible(toSlider);

fromSlider.oninput = () => controlFromSlider(fromSlider, toSlider, fromInputText);
toSlider.oninput = () => controlToSlider(fromSlider, toSlider, toInputText);

fromSlider.addEventListener('change', applyFilters);
toSlider.addEventListener('change', applyFilters);

async function fetchAllItems() {
    const itemsQuery = query(collection(db, "item") , where("quantity", ">", 0));//
    const querySnapshot = await getDocs(itemsQuery);
    return querySnapshot.docs.map(doc => doc.data());
}
async function fetchFavouriteItems(userEmail) {
    const favouritesQuery = query(collection(db, "Favourites"), where("email", "==", userEmail));
    const querySnapshot = await getDocs(favouritesQuery);
    return querySnapshot.docs.map(doc => doc.data());
}
function paginateItems(items, pageNumber, pageSize) {
    const startIndex = (pageNumber - 1) * pageSize;
    return items.slice(startIndex, startIndex + pageSize);
}

function filterItems(items, pageNumber, pageSize) {
    const startIndex = (pageNumber - 1) * pageSize;
    return items.slice(startIndex, startIndex + pageSize);
}

function displayCurrentPage(items) {
    const productsGrid = document.querySelector('.products-grid');
    productsGrid.innerHTML = '';

    let itemId= 0;
    items.forEach((item) => {
        const productContainer = document.createElement('div');
        productContainer.className = 'product-container';
        productContainer.id = `product-${item.name}`;
        productContainer.setAttribute('data-id', itemId);

        productContainer.addEventListener('click', () => {
            generateDialogContent(`${item.name}`);
        });

        // Create the image section
        const imgSection = document.createElement('div');
        imgSection.className = 'img-section';
        const imgWrapper = document.createElement('div');
        imgWrapper.className = 'img-wrapper';
        const img = document.createElement('img');
        img.src = item.preview_image;
        img.width = 115;
        img.height = 115;
        img.style.borderRadius = '10px';



        const iconContainer = document.createElement('div');
        iconContainer.className = 'icon-container';

        const heartIconContainer = document.createElement('div');
        heartIconContainer.className = 'heart-icon-container';
        const favouriteItem = favouriteItems.find(item_fav => item_fav.name === item.name); // Assuming `item.name` is the name of your current item

// Check if the item was found in the favourites

        const itemIsFavourite = Boolean(favouriteItem); // Converts the result to a boolean

        heartIconContainer.innerHTML = itemIsFavourite ?
        `<i class="rts" data-size="24" data-color="#000000" style="width: 24px; height: 24px;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" style="width: 24px; height: 24px;"><path d="M14.05,6.72C8.17.2,2.57,7.54,3.67,11.76,5.56,19,14.05,23.57,14.05,23.57s7.74-4.16,10.39-11.81C25.86,7.64,20.24.13,14.05,6.72Z" style="fill:#000000;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-width:2px"></path></svg></i>` :
        `<i class="rts" data-size="24" data-color="#000000" style="width: 24px; height: 24px;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" style="width: 24px; height: 24px;"><path d="M14.05,6.72C8.17.2,2.57,7.54,3.67,11.76,5.56,19,14.05,23.57,14.05,23.57s7.74-4.16,10.39-11.81C25.86,7.64,20.24.13,14.05,6.72Z" style="fill:none;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-width:2px"></path></svg></i>`; // Example with FontAwesome

        // Adding your new icon
        const newIconContainer = document.createElement('div');
        newIconContainer.className = 'new-icon-container';
        newIconContainer.innerHTML = `<i class="rts" data-size="24" data-color="#000000" style="width: 26px; height: 26px;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" style="width: 24px; height: 24px;"><path d="M21.46,26H6.54C4,26,4,23.86,4,22.46V2H24V22.46C24,23.86,24,26,21.46,26Z" style="fill:none;stroke:#000000;stroke-miterlimit:10;stroke-width:2px"></path><path d="M10,8v.78c0,2.68,1.8,4.88,4,4.88s4-2.19,4-4.88V8" style="fill:none;stroke:#000000;stroke-miterlimit:10;stroke-width:2px"></path></svg></i>`;


        heartIconContainer.addEventListener('mouseenter', (event) => {
            const favouriteItem = favouriteItems.find(item_fav => item_fav.name === item.name); // Assuming `item.name` is the name of your current item
            const isFavBefore = Boolean(favouriteItem); // Converts the result to a boolean
            let message_fav = isFavBefore ? "Remove from favorites" : "Add to favorites";

            showTooltip(event, message_fav)
        });
        heartIconContainer.addEventListener('click', async (event) => {
            const favouriteItem = favouriteItems.find(item_fav => item_fav.name === item.name); // Assuming `item.name` is the name of your current item
            const isFavBefore = Boolean(favouriteItem); // Converts the result to a boolean

            // Stop the event from propagating to other elements
            event.stopPropagation();
            try {
                // Replace `yourItemId` with the actual item ID or any identifier you use
                const response = await fetch('{% url "change_favorite_state" %}', {
                    method: 'POST', // or 'DELETE' if removing from favorites
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken'),

                        // Include other headers as needed, like authorization tokens
                    },
                    body: JSON.stringify({item: JSON.stringify(item), "alreadyFavourite": isFavBefore ? "true":"false"}),
                });

                if (!response.ok) throw new Error('Network response was not ok.');

                // Assuming the backend responds with the updated favorite status
                const data = await response.json();
                const isFavourite = data.isFavourite === "true";
                const itemToAddOrRemove = JSON.parse(data.item); // Assuming this is an object {name_id: "someId", ...}
                console.log("To add or remove" );
                console.log( itemToAddOrRemove);
                console.log("Is fav" );
                console.log( isFavourite);
                const existingTooltip = document.querySelector('.custom-tooltip');
                if (existingTooltip) {
                    existingTooltip.remove();
                }
                if (isFavourite) {

                    // Add to favoriteItems if not already present
                    const exists = favouriteItems.some(item => item.name === itemToAddOrRemove.name);
                    console.log("consists equals " + exists.toString());
                    if (!exists) {
                        favouriteItems.push(itemToAddOrRemove);
                        console.log("Added to favorites", itemToAddOrRemove);
                    }
                } else {
                    // Remove from favoriteItems

                    favouriteItems = favouriteItems.filter(item => item.name !== itemToAddOrRemove.name);
                    console.log("Removed from favorites", itemToAddOrRemove);
                }

                // Update the heart icon based on `isFavourite`
                heartIconContainer.innerHTML = isFavourite ?
                    `<i class="rts" data-size="24" data-color="#000000" style="width: 24px; height: 24px;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" style="width: 24px; height: 24px;"><path d="M14.05,6.72C8.17.2,2.57,7.54,3.67,11.76,5.56,19,14.05,23.57,14.05,23.57s7.74-4.16,10.39-11.81C25.86,7.64,20.24.13,14.05,6.72Z" style="fill:#000000;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-width:2px"></path></svg></i>` :
                    `<i class="rts" data-size="24" data-color="#000000" style="width: 24px; height: 24px;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 28 28" style="width: 24px; height: 24px;"><path d="M14.05,6.72C8.17.2,2.57,7.54,3.67,11.76,5.56,19,14.05,23.57,14.05,23.57s7.74-4.16,10.39-11.81C25.86,7.64,20.24.13,14.05,6.72Z" style="fill:none;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-width:2px"></path></svg></i>`;
            } catch (error) {
                console.error('Error updating favorites:', error);
            }
        });
        // Add event listeners for the new icon
        newIconContainer.addEventListener('mouseenter', (event) => showTooltip(event, 'Add to cart'));
        // Append both icon containers to the iconContainer

        iconContainer.appendChild(newIconContainer);
        iconContainer.appendChild(heartIconContainer);
        // Finally, append the iconContainer to the imgWrapper or imgSection

        imgWrapper.appendChild(img);
        imgWrapper.appendChild(iconContainer);
        // Append the imgWrapper to the imgSection
        imgSection.appendChild(imgWrapper);
        // Create the info section
        const infoSection = document.createElement('div');
        infoSection.className = 'info-section';
        const nameSpan = document.createElement('span');
        nameSpan.className = 'info-name';
        nameSpan.textContent = item.name;
        const priceSpan = document.createElement('span');
        priceSpan.className = 'info-price';
        priceSpan.textContent = currency + `${item.price}`;
        infoSection.appendChild(nameSpan);
        infoSection.appendChild(document.createElement('br'));
        infoSection.appendChild(priceSpan);





        // Assemble the product container
        productContainer.appendChild(imgSection);
        productContainer.appendChild(infoSection);

        // Append the product container to the products grid
        productsGrid.appendChild(productContainer);
        itemId+=1;
    });
}
function showTooltip(event, message) {
     const existingTooltip = document.querySelector('.custom-tooltip');
    if (existingTooltip) {
        existingTooltip.remove();
    }
    const tooltip = document.createElement('div');
    tooltip.className = 'custom-tooltip';
    tooltip.textContent = message;
    tooltip.style.position = 'absolute';
    tooltip.style.left = `${event.pageX + 10}px`; // Adjust positioning as needed
    tooltip.style.top = `${event.pageY + 10}px`; // Adjust positioning as needed
    document.body.appendChild(tooltip);

    // Move tooltip with cursor
    event.target.addEventListener('mousemove', (e) => {
        tooltip.style.left = `${e.pageX + 10}px`;
        tooltip.style.top = `${e.pageY + 10}px`;
    });

    // Remove tooltip on mouseleave
    event.target.addEventListener('mouseleave', () => {
        tooltip.remove();
    });
}
function applyFilters() {
   const nameFilterValue = document.getElementById('contains-in-name').value.toLowerCase();
   const [from, to] = getParsed(fromSlider, toSlider);

   filteredItems = allItems.filter(item =>
       (category === "All" || item.category === category) &&
       item.price <= to &&
       item.price >=from &&
       item.name.toLowerCase().includes(nameFilterValue)&&
      (baseFilters.length === 0 || baseFilters.includes(item.material)) && // Check base material
    (
        // Handle plating selection
        platingFilters.length === 0 ?
            (
                stoneFilters.length === 0 ?
                    (
                        // If no stone filter is selected, check size within any plating if size filter is applied
                        sizeFilters.length === 0 || Object.values(item.platings).some(plating =>
                            Object.values(plating.stones).some(stone =>
                                Object.keys(stone.sizes).some(sizeKey => sizeFilters.includes(sizeKey))
                            )
                        )
                    ) :
                    (
                        // If a stone filter is selected, look for the stone within any plating
                        Object.values(item.platings).some(plating =>
                            Object.keys(plating.stones).some(stoneKey =>
                                stoneFilters.includes(stoneKey) &&
                                (
                                    sizeFilters.length === 0 ||
                                    Object.keys(plating.stones[stoneKey].sizes).some(sizeKey => sizeFilters.includes(sizeKey))
                                )
                            )
                        )
                    )
            ) :
            (
                // When a plating filter is selected, restrict searches within that plating
                platingFilters.some(platingFilter =>
                    item.platings.hasOwnProperty(platingFilter) && // Check if item has the plating
                    (
                        stoneFilters.length === 0 ?
                            (
                                // Check sizes within the selected plating if no stone filter is selected
                                sizeFilters.length === 0 || Object.values(item.platings[platingFilter].stones).some(stone =>
                                    Object.keys(stone.sizes).some(sizeKey => sizeFilters.includes(sizeKey))
                                )
                            ) :
                            (
                                // Check for the specific stone and sizes within the selected plating
                                Object.keys(item.platings[platingFilter].stones).some(stoneKey =>
                                    stoneFilters.includes(stoneKey) &&
                                    (
                                        sizeFilters.length === 0 ||
                                        Object.keys(item.platings[platingFilter].stones[stoneKey].sizes).some(sizeKey => sizeFilters.includes(sizeKey))
                                    )
                                )
                            )
                    )
                )
            )
    )

   );
    if(filteredItems.length === 0){
        filteredItems.push("No items found");
    }
    {#console.log(filteredItems);#}
   currentPage = 1;
   total_pages = Math.ceil(filteredItems.length / itemsPerPage);
   changePage(1);
}
function checkSizes(item){

    let value = Object.values(item.platings).some(plating =>
        Object.values(plating.stones).some(stone => {
            // Check if stone has sizes and if any of these sizes match the sizeFilters
            return stone.sizes && Object.keys(stone.sizes).some(sizeKey => {
                const isMatch = sizeFilters.includes(sizeKey);
                return isMatch; // Correctly return the evaluation to influence the "some" method
            });
        })
    );
    return value;
}
function order(array){
    if(order_name==="Name") {
        array.sort((a, b) => {
            if(order_type==="asc") {
                if (a.name < b.name) {
                    return -1;
                }
                if (a.name > b.name) {
                    return 1;
                }
                return 0;
            }
            else if(order_type==="desc") {
                if (a.name > b.name) {
                    return -1;
                }
                if (a.name < b.name) {
                    return 1;
                }
                return 0;
            }
        });
    }
    else if (order_name==="Price"){
        array.sort((a, b) => {
            if(order_type==="asc") {
                if (a.price < b.price) {
                    return -1;
                }
                if (a.price > b.price) {
                    return 1;
                }
                return 0;
            }
            else if(order_type==="desc") {
                if (a.price > b.price) {
                    return -1;
                }
                if (a.price < b.price) {
                    return 1;
                }
                return 0;
            }
        });
    }
}
function updatePage() {
    let paginatedItems;
    let found = true;
    if(filteredItems.length === 0){
        order(allItems);
        paginatedItems = paginateItems(allItems, currentPage, itemsPerPage);
    }
    else{
        if(filteredItems[0] === "No items found"){
            paginatedItems = paginateItems([], currentPage, itemsPerPage);

            found = false;
        }
        else {
            order(filteredItems);
            paginatedItems = paginateItems(filteredItems, currentPage, itemsPerPage);
        }
    }
    const current = document.getElementById('current-page');
    current.innerText="Current page: " + currentPage;
    displayCurrentPage(paginatedItems);
    if(found===false){
        const grid = document.querySelector('.products-grid');
        const span = document.createElement('h2');
        span.textContent = "No items found";
        span.style.gridColumn = "1/-1";
        span.style.textAlign = 'center';
        span.style.color = "#4d4d4d"
        grid.appendChild(span);
    }
}

function productsTransmutation(items){

    let products = {};
    const regex = /^[a-zA-Z]{0,2}\d{5}[a-zA-Z]{0,5}$/;
    items.forEach(item => {

        let itemName = item.name;

        itemName = itemName.split(' ')[0];//.replace(/[a-zA-Z]/g, '').replace(/RG/g, '').replace(/G/g, '').replace(/R/g, '').replace(/XL/g, '').replace(/L/g, '').replace(/M/g, '').replace(/S/g, '').replace(/XS/g, '');

         if (regex.test(itemName)) {
            let processedName = itemName.match(/^([a-zA-Z]{0,2})(\d{5})/);
             // This includes both the initial letters and the 5 digits
             itemName = processedName[0];
        } else {
            itemName = (item.name).split(' ')[0];
        }

        if (!products[itemName] ) { //&& item.plating && item.stone
                products[itemName] = {
                    name: itemName,
                    description: item.description,
                    price:((price_category === "VK3" ? item.priceVK3 : price_category === "GH" ? item.priceGH : price_category === "GH_USD" ? item.priceUSD_GH : price_category === "Default_USD" ? item.priceUSD : (item.priceVK4*(1-sale)))? (price_category === "VK3" ? item.priceVK3 : price_category === "GH" ? item.priceGH : price_category === "GH_USD" ? item.priceUSD_GH : price_category === "Default_USD" ? item.priceUSD : (item.priceVK4*(1-sale))) : 0).toFixed(2),
                    category: item.category,
                    material: item.material,
                    preview_image: item.image_url,
                    platings: {}
                };
            }
            if (item.plating) {
                // Initialize plating if it doesn't exist.
                if (!products[itemName].platings[item.plating]) {
                    products[itemName].platings[item.plating] = {
                        stones: {},
                    };
                }

                // Proceed only if stone is defined.
                if (item.stone) {
                    // Initialize the stone if it doesn't exist under the current plating.
                    if (!products[itemName].platings[item.plating].stones[item.stone]) {
                        products[itemName].platings[item.plating].stones[item.stone] = {
                            sizes: {},
                            image: item.image_url,
                            real_name: item.name

                        };
                    }

                    // If size is present, add or update the size and quantity for the stone.
                    if (item.size) {
                        let stoneSizes = products[itemName].platings[item.plating].stones[item.stone].sizes;
                        if (!stoneSizes[item.size]) {
                            stoneSizes[item.size] = {'quantity': item.quantity, 'real_name':item.name };
                            {#console.log(stoneSizes[item.size]);#}
                            {#stoneSizes['real_name'] =  item.name;#}
                        } else {
                            // Assuming you want to sum quantities for the same size.
                            stoneSizes[item.size].quantity += item.quantity;
                        }
                    } else {
                        // If there's no size, add the quantity directly to the stone.
                        if (!products[itemName].platings[item.plating].stones[item.stone].quantity) {
                            products[itemName].platings[item.plating].stones[item.stone].quantity = item.quantity;
                            products[itemName].platings[item.plating].stones[item.stone].real_name = item.name;
                        } else {
                            products[itemName].platings[item.plating].stones[item.stone].quantity += item.quantity;
                        }
                    }
                }
            }



    });
    return Object.values(products);
}



document.getElementById('previous-button').addEventListener('click', function (event){
    event.preventDefault();
    if(currentPage>1){
        currentPage-=1;
        changePage(currentPage);
    }
});

document.getElementById('next-button').addEventListener('click', function (event){
    event.preventDefault();
    if(currentPage<total_pages){
        currentPage+=1;
        changePage(currentPage);
    }
});

document.getElementById('button-jump-to').addEventListener('click', function (event) {
    event.preventDefault();
    let page_number = Number(document.getElementById('page-number-input').value);
    if(page_number>0 && page_number<=total_pages){
        currentPage = page_number;
        changePage(currentPage);
    }
});

document.getElementById('select-items-per-page').addEventListener('change', function (event) {
    itemsPerPage = Number(event.target.value);
    if(filteredItems.length === 0) {
        total_pages = Math.ceil(allItems.length / itemsPerPage);
    }
    else{
         total_pages = Math.ceil(filteredItems.length / itemsPerPage);
    }
    currentPage = 1;
    changePage(1);
});
document.getElementById('select-order').addEventListener('change', function (event) {
    let order = (event.target.value).split(', ');
    console.log(order[0]);
    order_name = order[0];
    order_type=order[1];
    changePage(1);
});

 $(document).ready(function(){
    $('.slider').on('input change', function() {
        const container_shows = document.getElementById('value-of-slider-price');
        container_shows.innerText = $(this).val();
    });
});

document.querySelectorAll('.quantity-input-dialog').forEach(input => {
    input.addEventListener('input', function() {
        console.log(this.value);
    })
});
document.querySelectorAll('.quantity-input-dialog').forEach(input => {
    input.addEventListener('change', function() {
        console.log(this.value);
    })
});

function fulfilDropdown(dropdown, array){
    if(array) {
        (Object.keys(array)).forEach(element => {
            let option = document.createElement('option');
            option.innerText = element;
            option.value = element;
            dropdown.add(option);
        });
    }
}
function updatePlatings(selectedPlating, stoneSelect, sizeSelect, image, maxQuantity){
    const firstStone = selectedPlating ? Object.values(selectedPlating.stones || {})[0] : null;

    while (stoneSelect.firstChild) {
        stoneSelect.removeChild(stoneSelect.firstChild);
    }
    fulfilDropdown(stoneSelect, selectedPlating.stones);
    updateStones(firstStone, sizeSelect, image, maxQuantity);
}
function updateStones(selectedStone, sizeSelect, image, maxQuantity){

    const firstSizeKey = selectedStone ? Object.keys(selectedStone.sizes || {})[0] : null;
    const withSizes = !!firstSizeKey;
    const firstSizeQuantity = withSizes ? selectedStone.sizes[firstSizeKey].quantity : selectedStone.quantity;
    if (selectedStone?.image) {
        image.src = selectedStone.image; // Update the image src
    }

    while (sizeSelect.firstChild) {
        sizeSelect.removeChild(sizeSelect.firstChild);
    }
    if(withSizes) {
        fulfilDropdown(sizeSelect, selectedStone.sizes);
        updateSizes(firstSizeQuantity, maxQuantity);
    }
    else{
        maxQuantity.innerText = "In Stock: "+firstSizeQuantity;
    }
}

function updateSizes(sizeQuantity, maxQuantity){
    maxQuantity.innerText = "In stock: "+sizeQuantity;
    quantity_max = Number(sizeQuantity);
}

let quantity_max = 1;
function generateDialogContent(id){

    document.body.style.overflow = 'hidden';
    const item = allItems.find(item => item.name === id);
    console.log(item);
    if (!item) {
        console.error('Item not found');
        return;
    }

    const firstPlatingKey = Object.keys(item.platings)[0];
    const firstPlating = item.platings[firstPlatingKey];

    // Get the first stone in the first plating
    const firstStoneKey = firstPlating && Object.keys(firstPlating.stones)[0];
    const firstStone = firstPlating ? firstPlating.stones[firstStoneKey] : null;

    // Get the first size in the first stone
    const firstSizeKey = firstStone && Object.keys(firstStone.sizes)[0];
    const firstSizeQuantity = firstStone ? firstStone.sizes[firstSizeKey] ? firstStone.sizes[firstSizeKey].quantity: null : null;


    const dialog = document.getElementById('product-card');
    const image = document.createElement('img');
    bindGlobalClickEvent(dialog);
    dialog.innerHTML = '';

    const card_content = document.createElement('div');
    card_content.classList.add('card-content');

    let imagePath = '';

    if (firstStone) {
        imagePath = firstStone.image || '';
        quantity_max = Object.keys(firstStone.sizes || {}).length === 0 ? firstStone.quantity : firstSizeQuantity;
    }

    dialogCommonSetup(dialog, imagePath, card_content, image);

    const secondColumn = document.createElement('div');
    secondColumn.classList.add('second-column');

    const nameSpan = document.createElement('h1');
    nameSpan.textContent = `${item.name}`;
    secondColumn.appendChild(nameSpan);

    const priceSpan = document.createElement('div');
    priceSpan.textContent = currency+`${item.price}`;
    secondColumn.appendChild(priceSpan);

    const quantitySpan = document.createElement('div');
    quantitySpan.textContent = `In stock: ${quantity_max}`;
    quantitySpan.classList.add('maximum-span');

    const platingLabel = document.createElement('span');
    platingLabel.innerText = "Plating Material";
    platingLabel.classList.add('card-dropdown-label');
    const platingsSelect = document.createElement('select');
    platingsSelect.classList.add('card-dropdown');
    fulfilDropdown(platingsSelect, item.platings);
    secondColumn.appendChild(platingLabel);
    secondColumn.appendChild(platingsSelect);

    const stoneLabel = document.createElement('span');
    stoneLabel.innerText = "Stone color";
    stoneLabel.classList.add('card-dropdown-label');
    const stoneSelect = document.createElement('select');
    stoneSelect.classList.add('card-dropdown');
    fulfilDropdown(stoneSelect, firstPlating.stones);
    secondColumn.appendChild(stoneLabel);
    secondColumn.appendChild(stoneSelect);

    const sizeLabel = document.createElement('span');
    sizeLabel.innerText = "Size";
    sizeLabel.classList.add('card-dropdown-label');
    const sizeSelect = document.createElement('select');
    sizeSelect.classList.add('card-dropdown');
    if(Object.keys(firstStone.sizes).length>0) {
        fulfilDropdown(sizeSelect, firstStone.sizes);
        secondColumn.appendChild(sizeLabel);
        secondColumn.appendChild(sizeSelect);
    }
    const inputQuantity = document.createElement('input');

    platingsSelect.addEventListener('change', (event) => {
        const selectedPlatingKey = event.target.value;
        const selectedPlating = item.platings[selectedPlatingKey];
        inputQuantity.value = '1';
        updatePlatings(selectedPlating, stoneSelect, sizeSelect, image, quantitySpan);
    });
    stoneSelect.addEventListener('change', (event) => {
        const selectedStoneKey = event.target.value;
        const selectedPlatingKey = platingsSelect.value;
        const selectedPlating = item.platings[selectedPlatingKey];
        const selectedStone = selectedPlating && selectedPlating.stones ? selectedPlating.stones[selectedStoneKey] : null;
        inputQuantity.value = '1';
        updateStones(selectedStone, sizeSelect, image, quantitySpan);

    });

    sizeSelect.addEventListener('change', (event) => {
        const selectedSizeKey = event.target.value;
        const selectedPlatingKey = platingsSelect.value;
        const selectedPlating = item.platings[selectedPlatingKey];
        const selectedStoneKey = stoneSelect.value;
        const selectedSizeQuantity = selectedPlating.stones[selectedStoneKey].sizes[selectedSizeKey].quantity;
        inputQuantity.value = '1';
        updateSizes(selectedSizeQuantity, quantitySpan);

    });





    const bottom_part = document.createElement('div');
    bottom_part.classList.add('bottom-card-part');

    const counter = document.createElement('div');

    const button_minus = document.createElement('button');
    button_minus.innerText = '-';
    button_minus.classList.add('minus-button-dialog');

    inputQuantity.type = 'number';
    inputQuantity.style.textAlign = 'center';
    inputQuantity.value = 1;
    inputQuantity.classList.add('quantity-input-dialog');
    inputQuantity.min = '1';

    inputQuantity.addEventListener('input', function() {
        if(inputQuantity.value > quantity_max || inputQuantity.value < 1 ){
            if(inputQuantity.value > quantity_max){
                inputQuantity.value = quantity_max;
            }
            else{
                inputQuantity.value = 1;
            }
            alert('Quantity number has to be less than or equal to quantity number in stock or and be greater than 0');
        }
    });

    button_minus.addEventListener('click', () => {
        if(inputQuantity.value > 1)
            inputQuantity.value -= 1;
    });
    const button_plus = document.createElement('button');
    button_plus.innerText = '+';
    button_plus.classList.add('plus-button-dialog');
    button_plus.addEventListener('click', () => {

        if(inputQuantity.value<quantity_max) {
            let currentValue = Number(inputQuantity.value === "" ? 1 : inputQuantity.value);
            inputQuantity.value = currentValue + 1;
            {#console.log(item.name);#}
        }
    });
    counter.appendChild(button_minus);
    counter.appendChild(inputQuantity);
    counter.appendChild(button_plus);



    const add_to_cart = document.createElement('button');
    add_to_cart.type = 'submit';
    add_to_cart.classList.add('add-to-cart-dialog');
    add_to_cart.addEventListener('click', function() {
        add_to_cart_func(item, platingsSelect.value, stoneSelect.value, sizeSelect.value, Number(inputQuantity.value), add_to_cart, dialog);

    });
    const icon_cart = document.createElement('i');
    icon_cart.classList.add('fa-solid', 'fa-cart-shopping');
    add_to_cart.appendChild(icon_cart);
    const text_add_to_cart = document.createElement('span');
    text_add_to_cart.innerText = ' Add to cart';
    add_to_cart.appendChild(icon_cart);
    add_to_cart.appendChild(text_add_to_cart);
    bottom_part.appendChild(counter);
    bottom_part.appendChild(quantitySpan);
    bottom_part.appendChild(add_to_cart);
    secondColumn.appendChild(bottom_part);

    card_content.appendChild(secondColumn);
    dialog.appendChild(card_content);
    dialog.style.transform = 'translate(0%, 0%) scale(0)';

    dialog.showModal();
    setTimeout(() => {
    dialog.style.transform = 'translate(0%, 0%) scale(1)';
  }, 0); // 0 milliseconds delay is often enough to ensure the reapplication triggers the animation

    dialog.style.display = 'block';
 }
 function closeDialogWithAnimation(dialog) {
    dialog.style.transform = 'translate(0%, 0%) scale(0)';
    setTimeout(() => {
        dialog.style.display = 'none';
    dialog.close();
  }, 250); // 500 milliseconds is the duration of the animation
 }
function bindGlobalClickEvent(dialog) {
    document.addEventListener('click', (event) => {
        const rect = dialog.getBoundingClientRect();
        const isInDialog = (rect.top <= event.clientY && event.clientY <= rect.top + rect.height
                            && rect.left <= event.clientX && event.clientX <= rect.left + rect.width);

        // Check if the event target is inside a select element or another form control
        let targetElement = event.target;
        while (targetElement != null) {
            if (targetElement.tagName === 'SELECT' || targetElement.tagName === 'OPTION') {
                // If the click is inside the dialog or on a select element, do nothing
                return;
            }
            targetElement = targetElement.parentNode; // Move up the DOM tree
        }

        if (!isInDialog && dialog.open) {
            document.body.style.overflow = '';

            closeDialogWithAnimation(dialog);
        }
    }, true);
}
function add_to_cart_func(item, plating, stone, size, quantity, add_button, dialog){
    let doc;
    if( size === "" ){
         doc = item.platings[plating].stones[stone].real_name;
    }
    else{
         doc = item.platings[plating].stones[stone].sizes[size].real_name;
    }
    add_button.textContent = "Processing...";
    add_button.style.backgroundColor = "#7894a6";
    add_button.disabled = true;

    fetch('{% url "add_from_catalog" %}', {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCookie('csrftoken'),
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({'document': doc, 'quantity':quantity})
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {

            closeDialogWithAnimation(dialog);
            setTimeout(() => {
                activate_success_card(data.product, data.quantity, data.cart_size, data.subtotal);
            }, 0);

        } else {
            alert('An error occured: ' + data.error);
            closeDialogWithAnimation(dialog);
        }
    });
}
function activate_success_card(item, quantity, cart_count, subtotalValue){
    const dialog = document.getElementById('product-card-success');

    bindGlobalClickEvent(dialog);
    dialog.innerHTML = '';
    const card_content = document.createElement('div');
    card_content.classList.add('success-card-content');
    const image = document.createElement('img');
    dialogCommonSetup(dialog, item.image_url, card_content, image);

    //Column with text information and everything about added to cart product
    const secondColumn = document.createElement('div');
    secondColumn.classList.add('second-column');

    //Add information about added the product and about the cart
    informationSuccessSetup(secondColumn, item, quantity, cart_count, subtotalValue);

    //Add buttons to continue shopping or to procceed to checkout
    manageButtonsSuccessSetup(dialog, secondColumn);

    card_content.appendChild(secondColumn);
    dialog.appendChild(card_content);

    setTimeout(() => {
        dialog.showModal();
        dialog.style.transform = 'translate(0%, 0%) scale(1)';
    }, 249); // 0 milliseconds delay is often enough to ensure the reapplication triggers the animation
    dialog.style.display = 'block';

}
function dialogCommonSetup(dialog, image_url, card_content, image){

    image.src = image_url;
    image.width = `400`;
    image.height = `400`;
    image.classList.add('img-card');
    card_content.appendChild(image);

    const close_dialog = document.createElement('div');
    const icon_close = document.createElement('i');
    icon_close.classList.add('fa-solid', 'fa-close');
    close_dialog.appendChild(icon_close);
    close_dialog.addEventListener('click',()=>{
       document.body.style.overflow = '';
       closeDialogWithAnimation(dialog);
    });

    close_dialog.classList.add('close-card');
    card_content.appendChild(close_dialog);

}
function informationSuccessSetup(column, item, actual_quantity, cart_count, cartSubtotal){
    const addedText = document.createElement('h4');
    addedText.classList.add('added-text');
    addedText.innerHTML = `<i class='fa-solid fa-check'></i> `+`Product successfully added to your shopping cart`;
    column.appendChild(addedText);
    const nameSpan = document.createElement('h3');
    nameSpan.textContent = `${item.name}`;
    column.appendChild(nameSpan);

    const priceSpan = document.createElement('div');
    priceSpan.textContent = currency + `${item.price}`;
    column.appendChild(priceSpan);

    const platingSpan = document.createElement('spanSucc');
    platingSpan.innerHTML= `<strong>Plating material: </strong>` + `${item.plating}`;
    column.appendChild(platingSpan);
    const crystalSpan = document.createElement('spanSucc');
    crystalSpan.innerHTML = `<strong>Crystal color: </strong> ` +`${item.stone}`;
    column.appendChild(crystalSpan);
    const baseSpan = document.createElement('spanSucc');
    baseSpan.innerHTML =`<strong>Base material: </strong> ` + `${item.material}`;
    column.appendChild(baseSpan);

    const quantitySpan = document.createElement('spanSucc');
    quantitySpan.innerHTML = `<strong>Quantity: </strong> ` + `${actual_quantity}`;
    quantitySpan.style.marginBottom = '20px';
    column.appendChild(quantitySpan);

    const items_count = document.createElement('spanSucc');
    items_count.textContent = `There are ${cart_count} items in your cart.`;
    column.appendChild(items_count);

    const subtotal = document.createElement('spanSucc');
    subtotal.innerHTML =`<strong>Subtotal: </strong>`+currency + `${cartSubtotal}`;
    subtotal.style.marginBottom = '20px';
    column.appendChild(subtotal);
}
function manageButtonsSuccessSetup(dialog, column){
    const container_for_success_buttons = document.createElement('div');
    const continue_shopping = document.createElement('button');
    continue_shopping.classList.add('button-continue-shopping');
    continue_shopping.textContent = 'Continue shopping';
    container_for_success_buttons.appendChild(continue_shopping);

    continue_shopping.addEventListener('click', ()=>{
         document.body.style.overflow = '';
        closeDialogWithAnimation(dialog);
    });

    const proceed_to_checkout = document.createElement('a');
    proceed_to_checkout.textContent = 'Proceed to checkout';
    proceed_to_checkout.classList.add('button-proceed-to-checkout');
    proceed_to_checkout.href = `{% url 'cart' %}`;

    container_for_success_buttons.appendChild(proceed_to_checkout);
    column.appendChild(container_for_success_buttons);
}
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}
</script>
</html>
{%endblock%}